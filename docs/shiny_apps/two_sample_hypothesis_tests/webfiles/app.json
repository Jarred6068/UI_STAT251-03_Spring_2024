[{"name":"app.R","content":"#\r\n# This is a Shiny web application. You can run the application by clicking\r\n# the 'Run App' button above.\r\n#\r\n# Find out more about building applications with Shiny here:\r\n#\r\n#    http://shiny.rstudio.com/\r\n#\r\n\r\nlibrary(shiny)\r\nlibrary(ggplot2)\r\nlibrary(ggthemes)\r\nlibrary(latex2exp)\r\nlibrary(gridExtra)\r\nlibrary(ggpubr)\r\n\r\n\r\n\r\n#unpooled standard error for difference in two proportions\r\ntwo.sample.prop.SE = function(p1,p2,n1,n2){\r\n  SE = sqrt((p1*(1-p1)/n1)+(p2*(1-p2)/n2))\r\n  return(SE)\r\n}\r\n\r\n#computing confidence intervals for the difference between two population proportions\r\ntwo.sample.prop.CI = function(p1,p2,n1,n2,tail = 'two.tail',alpha = 0.05, verbose = FALSE){\r\n  diff = p1-p2\r\n  bounds=c(0,0)\r\n  if(tail != 'two.tail'){\r\n    Z = qnorm(1-alpha)\r\n  }else{\r\n    Z = qnorm(1-(alpha/2))\r\n  }\r\n  SE = two.sample.prop.SE(p1,p2,n1,n2)\r\n  MOE = Z*SE\r\n  bounds[1] = diff - MOE\r\n  bounds[2] = diff + MOE\r\n  bounds = sort(bounds)\r\n  if(isTRUE(verbose)){\r\n    print(noquote(paste0(rep('-', 50), collapse = '')))\r\n    print(noquote(paste0('Estimate = ', round(diff, 4))))\r\n    print(noquote(paste0('Critical Value  = ', round(Z, 4))))\r\n    print(noquote(paste0('Estimated Standard Error = ', round(SE, 4))))\r\n    print(noquote(paste0('Margin of error = ', round(MOE, 4))))\r\n    print(noquote(paste0((1-alpha)*100, ' % CI = ', paste0('[',round(bounds[1], 4), ',', \r\n                                                           round(bounds[2], 4), ']'))))\r\n    print(noquote(paste0(rep('-', 50), collapse = '')))\r\n  }\r\n  \r\n  return(list(estimate = diff, interval = bounds, margin.of.error = MOE, critical.value = Z))\r\n}\r\n\r\n\r\n#two sample proportion test\r\ntwo.sample.prop.test = function(p0,x1,x2,n1,n2,alpha = 0.05, test = c('lower.tail','upper.tail','two.tail'),\r\n                                pooled = TRUE, verbose = TRUE){\r\n  \r\n  \r\n  p1 = x1/n1\r\n  p2 = x2/n2\r\n  estimate = p1 - p2\r\n  estimate.SE = two.sample.prop.SE(p1, p2, n1, n2)\r\n  if(isTRUE(pooled)){\r\n    calc = 'pooled'\r\n    p.pooled = (x1+x2)/(n1+n2)\r\n    test.SE = sqrt( (p.pooled*(1-p.pooled))*(1/n1 + 1/n2) )\r\n  }else{\r\n    calc = 'unpooled'\r\n    test.SE = two.sample.prop.SE(p1,p2,n1,n2) \r\n  }\r\n  Zobs = (estimate - p0)/test.SE\r\n  if(test == 'two.tail'){\r\n    critical.value = qnorm((1-(alpha/2)))\r\n    alt.hyp = 'p1 - p2 != '\r\n    pvalue = 2*(1-pnorm(abs(Zobs)))\r\n  }else if(test == 'lower.tail'){\r\n    critical.value = qnorm(alpha)\r\n    alt.hyp = 'p1 - p2 < '\r\n    pvalue = pnorm(Zobs)\r\n  }else{\r\n    critical.value = qnorm(1-alpha)\r\n    alt.hyp = 'p1 - p2 > '\r\n    pvalue = 1-pnorm(Zobs)\r\n  }\r\n  \r\n  CI = sort(c(estimate - critical.value * estimate.SE, estimate + critical.value * estimate.SE))\r\n  decision = ifelse(pvalue<alpha, 'reject H0', 'fail to reject H0')\r\n  if(isTRUE(verbose)){\r\n    print(noquote(paste0(paste0(rep('=', 20), collapse = ''), ' test results ', paste0(rep('=', 20), collapse = ''))))\r\n    print(noquote(paste0('test type = ', test)))\r\n    print(noquote(paste0('H0: p1 - p2 = ', p0)))\r\n    print(noquote(paste0('HA: ', alt.hyp, p0)))\r\n    print(noquote(paste0('estimate = ', round(estimate,4))))\r\n    print(noquote(paste0(calc,' SE = ', round(test.SE,4))))\r\n    print(noquote(paste0((1-alpha)*100, '% CI = ', paste0('[', max(round(CI[1],4), 0),',',\r\n                                                          round(CI[2],4),']', \r\n                                                          collapse = ''))))\r\n    print(noquote(paste0('Critical Value = ', round(critical.value,4))))\r\n    print(noquote(paste0('Test statistic = ', round(Zobs, 4))))\r\n    print(noquote(paste0('Pvalue = ', round(pvalue, 4))))\r\n    print(noquote(paste0('Decision: ', decision)))\r\n    print(noquote(paste0(rep(\"=\", 54), collapse = '')))\r\n  }\r\n} \r\n\r\n\r\n#two sample unpooled standard error for means \r\ntwo.sample.t.SE = function(s1,s2,n1,n2){\r\n  SE = sqrt((s1^2/n1)+(s2^2/n2))\r\n  return(SE)\r\n}\r\n\r\n#confidence intervals for a difference between two means\r\ntwo.sample.t.CI = function(x1,x2,s1,s2,n1,n2, tail = 'two.tail',alpha = 0.05, verbose = FALSE){\r\n  diff = x1-x2\r\n  bounds=c(0,0)\r\n  df = min(n1-1, n2-1)\r\n  if(tail != 'two.tail'){\r\n    t.crit = qt(1-alpha, df = df)\r\n  }else{\r\n    t.crit = qt(1-(alpha/2), df = df)\r\n  }\r\n  SE = two.sample.t.SE(s1,s2,n1,n2)\r\n  MOE = t.crit*SE\r\n  bounds[1] = diff - MOE\r\n  bounds[2] = diff + MOE\r\n  bounds = sort(bounds)\r\n  if(isTRUE(verbose)){\r\n    print(noquote(paste0(rep('-', 50), collapse = '')))\r\n    print(noquote(paste0('Estimate = ', round(diff, 4))))\r\n    print(noquote(paste0('Critical Value  = ', round(t.crit, 4))))\r\n    print(noquote(paste0('Estimated Standard Error = ', round(SE, 4))))\r\n    print(noquote(paste0('Margin of error = ', round(MOE, 4))))\r\n    print(noquote(paste0((1-alpha)*100, ' % CI = ', paste0('[',round(bounds[1], 4), ',', \r\n                                                           round(bounds[2], 4), ']'))))\r\n    print(noquote(paste0(rep('-', 50), collapse = '')))\r\n  }\r\n  \r\n  return(list(estimate = diff, interval = bounds, margin.of.error = MOE, critical.value = t.crit))\r\n}\r\n\r\n\r\n#two sample t test \r\ntwo.sample.t.test = function(m0,x1,x2,s1,s2,n1,n2,alpha = 0.05, test = c('lower.tail','upper.tail','two.tail'),\r\n                             pooling = c('pooled', 'unpooled','approx.unpooled'), verbose = TRUE){\r\n  \r\n  estimate = x1 - x2\r\n  estimate.SE = two.sample.t.SE(s1, s2, n1, n2)\r\n  if(pooling == 'pooled'){\r\n    calc = 'pooled'\r\n    df = n1 + n2 - 2\r\n    s.pooled = sqrt( ((n1-1)*s1^2 + (n2-1)*s2^2)/(n1+n2-2))\r\n    test.SE = s.pooled * sqrt((1/n1)+(1/n2))\r\n  }else if (pooling == 'unpooled'){\r\n    calc = 'exact.unpooled'\r\n    df = (((s1^2/n1)+(s2^2/n2))^2)/(((s1^2/n1)^2/(n1-1)) + ((s2^2/n2)^2/(n2-1)))\r\n    test.SE = two.sample.t.SE(s1,s2,n1,n2) \r\n  }else{\r\n    calc = 'approx.unpooled'\r\n    df = min(n1-1, n2-1)\r\n    test.SE = two.sample.t.SE(s1,s2,n1,n2) \r\n  }\r\n  tobs = (estimate - m0)/test.SE\r\n  if(test == 'two.tail'){\r\n    critical.value = qt((1-(alpha/2)), df = df)\r\n    alt.hyp = 'm1 - m2 != '\r\n    pvalue = 2*(1-pt(abs(tobs), df = df))\r\n  }else if(test == 'lower.tail'){\r\n    critical.value = qt(alpha, df = df)\r\n    alt.hyp = 'm1 - m2 < '\r\n    pvalue = pnorm(tobs)\r\n  }else{\r\n    critical.value = qt(1-alpha, df = df)\r\n    alt.hyp = 'm1 - m2 > '\r\n    pvalue = 1-pnorm(tobs)\r\n  }\r\n  \r\n  CI = sort(c(estimate - critical.value * estimate.SE, estimate + critical.value * estimate.SE))\r\n  decision = ifelse(pvalue<alpha, 'reject H0', 'fail to reject H0')\r\n  if(isTRUE(verbose)){\r\n    print(noquote(paste0(paste0(rep('=', 20), collapse = ''), ' test results ', paste0(rep('=', 20), collapse = ''))))\r\n    print(noquote(paste0('test type = ', test)))\r\n    print(noquote(paste0('H0: m1 - m2 = ', m0)))\r\n    print(noquote(paste0('HA: ', alt.hyp, m0)))\r\n    print(noquote(paste0('estimate = ', round(estimate,4))))\r\n    print(noquote(paste0(calc,' SE = ', round(test.SE,4))))\r\n    print(noquote(paste0((1-alpha)*100, '% CI = ', paste0('[',round(CI[1],4),',',\r\n                                                          round(CI[2],4),']', \r\n                                                          collapse = ''))))\r\n    print(noquote(paste0('Critical Value = ', round(critical.value,4))))\r\n    print(noquote(paste0('Test statistic = ', round(tobs, 4))))\r\n    print(noquote(paste0(calc,' degrees of freedom = ', round(df, 4))))\r\n    print(noquote(paste0('Pvalue = ', round(pvalue, 4))))\r\n    print(noquote(paste0('Decision: ', decision)))\r\n    print(noquote(paste0(rep(\"=\", 54), collapse = '')))\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Define UI for application that draws a histogram\r\nui <- fluidPage(\r\n  \r\n  titlePanel('Two-Sample Hypothesis Tests'),\r\n  sidebarLayout(\r\n    sidebarPanel(width = 4, \r\n                 #input select\r\n                 selectInput(inputId = \"param\",\r\n                             label = \"Which Comparison\",\r\n                             choices = c(\"two.means\", \"two.proportions\"),\r\n                             selected = \"two.means\"),\r\n                 \r\n                 selectInput(inputId = \"test\",\r\n                             label = \"Choose inference type:\",\r\n                             choices = c(\"confidence.interval\",\"upper.tail\", \r\n                                         \"lower.tail\", \"two.tail\"),\r\n                             selected = \"two.tail\"),\r\n                 \r\n                 sliderInput(inputId = \"alpha\",\r\n                             label = \"Significance Level:\",\r\n                             min = 0,\r\n                             max = 1,\r\n                             step = 0.01,\r\n                             value = 0.05),\r\n                 \r\n                 numericInput(inputId = \"n1\",\r\n                              label = \"Sample Size Pop1: n1 \",\r\n                              value = 12),\r\n                 \r\n                 numericInput(inputId = \"n2\",\r\n                              label = \"Sample Size Pop2: n2 \",\r\n                              value = 10),\r\n                 \r\n                 conditionalPanel(condition = \"input.param == 'two.means'\",\r\n                                  numericInput(inputId = \"m0\",\r\n                                               label = \"Set null value H_0: mu1 - mu2 = \",\r\n                                               value = 0),\r\n                                  numericInput(inputId = \"xbar1\",\r\n                                               label = \"Sample Mean Pop1: xbar1\",\r\n                                               value = 4),\r\n                                  numericInput(inputId = \"xbar2\",\r\n                                               label = \"Sample Mean Pop2: xbar2\",\r\n                                               value = 5),\r\n                                  numericInput(inputId = \"s1\",\r\n                                               label = \"Sample Standard Dev. Pop1: s1 \",\r\n                                               value = 1),\r\n                                  numericInput(inputId = \"s2\",\r\n                                               label = \"Sample Standard Dev. Pop2: s2 \",\r\n                                               value = 1),\r\n                                  selectInput(inputId = \"pooling\",\r\n                                              label = \"Choose pooling option:\",\r\n                                              choices = c(\"pooled\", \"unpooled\", \"approx.unpooled\"),\r\n                                              selected = \"approx.unpooled\")),\r\n                 \r\n                 conditionalPanel(condition = \"input.param == 'two.proportions'\",\r\n                                  numericInput(inputId = \"p0\",\r\n                                               label = \"Set null difference H_0: p1 - p2 = \",\r\n                                               value = 0,\r\n                                               min = 0,\r\n                                               max = 1,\r\n                                               step = 0.01),\r\n                                  numericInput(inputId = \"x1\",\r\n                                               label = \"Observed count for population 1: x1\",\r\n                                               min = 0,\r\n                                               value = 10),\r\n                                  numericInput(inputId = \"x2\",\r\n                                               label = \"Observed count for population 2: x2\",\r\n                                               min = 0,\r\n                                               value = 8)),\r\n                 actionButton(\"run\",\"Run Inference\"),\r\n    ),\r\n    mainPanel(plotOutput(\"plotresult\"), \r\n              verbatimTextOutput(\"summary\"))\r\n  )\r\n)\r\n\r\n# Define server logic required to draw a histogram\r\nserver <- function(input, output) {\r\n  \r\n  observeEvent(input$run,  output$plotresult <- renderPlot({\r\n    if(input$param == 'two.means'){\r\n      lbl.height = 0.1\r\n      distrib = 't'\r\n      estimate = input$xbar1 - input$xbar2\r\n      if(input$pooling == 'pooled'){\r\n        df = input$n1 + input$n2 - 2\r\n        s.pooled = sqrt( ((input$n1-1)*input$s1^2 + (input$n2-1)*input$s2^2)/(input$n1+input$n2-2))\r\n        SE = s.pooled * sqrt((1/input$n1)+(1/input$n2))\r\n      }else if (input$pooling == 'unpooled'){\r\n        df = ( ( (input$s1^2/input$n1)+(input$s2^2/input$n2) )^2)/(((input$s1^2/input$n1)^2/(input$n1-1)) + ((input$s2^2/input$n2)^2/(input$n2-1)))\r\n        SE = two.sample.t.SE(input$s1,input$s2,input$n1,input$n2)\r\n      }else if(input$pooling == 'approx.unpooled'){\r\n        df = min(input$n1-1, input$n2-1)\r\n        SE = two.sample.t.SE(input$s1,input$s2,input$n1,input$n2)\r\n      }\r\n      standard.score = qt(1-input$alpha/2, df)\r\n      LV = estimate - 4*SE\r\n      UV = estimate + 4*SE\r\n      LB = estimate - standard.score*SE\r\n      UB = estimate + standard.score*SE\r\n      calc = '\\\\bar{x}_1 - \\\\bar{x}_2 = '\r\n      est1 = '$\\\\bar{x}_1$'\r\n      est2 = '$\\\\bar{x}_2$'\r\n      est.val1 = input$xbar1\r\n      est.val2 = input$xbar2\r\n      est.sd1 = input$s1/sqrt(input$n1)\r\n      est.sd2 = input$s2/sqrt(input$n2)\r\n    }else{\r\n      lbl.height = 0.2\r\n      distrib = 'z'\r\n      estimate = (input$x1/input$n1) - (input$x2/input$n2)\r\n      p.pooled = (input$x1+input$x2)/(input$n1+input$n2)\r\n      SE = sqrt( (p.pooled*(1-p.pooled))*(1/input$n1 + 1/input$n2))\r\n      standard.score = qnorm(1-input$alpha/2)\r\n      LB = estimate - standard.score*SE\r\n      LV = estimate - 4*SE\r\n      UB = estimate + standard.score*SE\r\n      UV = estimate + 4*SE\r\n      calc = '\\\\hat{p}_1 - \\\\hat{p}_2 = '\r\n      est1 = '$\\\\hat{p}_1$'\r\n      est2 = '$\\\\hat{p}_2$'\r\n      est.val1 = input$x1/input$n1\r\n      est.val2 = input$x2/input$n2\r\n      est.sd1 = sqrt(est.val1*(1-est.val1)/input$n1)\r\n      est.sd2 = sqrt(est.val2*(1-est.val2)/input$n2)\r\n    }\r\n\r\n    if(input$test == 'confidence.interval'){\r\n      out = ggplot()+xlim(LV, UV)+\r\n        theme_bw()+\r\n        stat_function(fun = dnorm,\r\n                      args = list(mean = estimate, sd = SE),\r\n                      geom = 'area',\r\n                      fill = 'lightgrey')+\r\n        stat_function(fun = dnorm,\r\n                      args = list(mean = estimate, sd = SE),\r\n                      size = 2)+\r\n        geom_vline(xintercept = LB, linetype = 'dotted', size = 2)+\r\n        geom_vline(xintercept = UB, linetype = 'dotted', size = 2)+\r\n        geom_text(aes(x = estimate, y = dnorm(estimate, mean = estimate, sd = SE)/2),\r\n                  label = paste0(100*(1-input$alpha), '%', ' CI'), size = 8)+\r\n        \r\n        geom_label(aes(x = estimate, y = 0), \r\n                   label = TeX(paste0('$', calc, round(estimate, 2), '$')), size = 6)+\r\n        xlab('Estimate')+\r\n        ylab('Probability Density')+\r\n        theme(axis.text = element_text(size = 12),\r\n              axis.title = element_text(size = 14))\r\n\r\n    }else{\r\n      #browser()\r\n      idx = which(c(est.val1, est.val2) == min(est.val1, est.val2))\r\n      if(idx == 1){\r\n        LB = est.val1 - 4*est.sd1\r\n        UP = est.val2 + 4*est.sd2\r\n        added = est.val1+abs(est.val1 - est.val2)/2\r\n      }else{\r\n        LB = est.val2 - 4*est.sd2\r\n        UP = est.val1 + 4*est.sd1\r\n        added = est.val2+(est.val1 - est.val2)/2\r\n      }\r\n      arr.height = min(dnorm(est.val1, est.val1, est.sd1)/2,\r\n                       dnorm(est.val2, est.val2, est.sd2)/2)\r\n      out = ggplot()+xlim(LB, UP)+theme_pander()+\r\n        stat_function(fun = dnorm,\r\n                      args = list(mean = est.val1, sd = est.sd1),\r\n                      size = 1.5)+\r\n        stat_function(fun = dnorm,\r\n                      args = list(mean = est.val1, sd = est.sd1),\r\n                      geom = 'area',\r\n                      fill = 'red',\r\n                      alpha = 0.5)+\r\n        stat_function(fun = dnorm,\r\n                      args = list(mean = est.val2, sd = est.sd2),\r\n                      size = 1.5)+\r\n        stat_function(fun = dnorm,\r\n                      args = list(mean = est.val2, sd = est.sd2),\r\n                      geom = 'area',\r\n                      fill = 'blue',\r\n                      alpha = 0.5)+\r\n        \r\n        geom_segment(aes(x = est.val1, y = arr.height, \r\n                         xend = est.val2, yend = arr.height), #yend = dnorm(input$xbar2, input$xbar2, input$s2)/2), \r\n                     size = 1, \r\n                     arrow = arrow(length = unit(0.4, \"cm\"), ends = 'both'))+\r\n        \r\n        geom_segment(aes(x = est.val1, y = 0, \r\n                         xend = est.val1, yend = dnorm(est.val1, est.val1, est.sd1)), \r\n                     size = 1, linetype = 'dotted')+\r\n        \r\n        geom_segment(aes(x = est.val2, y = 0, \r\n                       xend =est.val2, yend = dnorm(est.val2, est.val2, est.sd2)), \r\n                   size = 1, linetype = 'dotted')+\r\n        \r\n        geom_label(aes(x = est.val1, y = dnorm(est.val1, est.val1, est.sd1)+0.01),\r\n                   label = 'Population 1', size = 6)+\r\n        \r\n        geom_label(aes(x = est.val2, y = dnorm(est.val2, est.val2, est.sd2)+0.01),\r\n                   label = 'Population 2', size = 6)+\r\n        \r\n        geom_label(aes(x = est.val1, y = 0),\r\n                   label = TeX(est1), size = 6)+\r\n        \r\n        geom_label(aes(x = est.val2, y = 0),\r\n                   label = TeX(est2), size = 6)+\r\n        \r\n        geom_label(aes(x = added, y = arr.height+lbl.height),\r\n                   label = TeX(paste0('$', calc, round(est.val1 - est.val2, 3), '$')),\r\n                   size = 5)+\r\n        xlab('')+\r\n        ylab('Density')+\r\n        theme(axis.text = element_text(size = 12),\r\n              axis.title = element_text(size = 14))\r\n    }\r\n    \r\n    plot(out)\r\n\r\n  }))\r\n\r\n  observeEvent(input$run,  output$summary <- renderPrint({\r\n    #browser()\r\n    if(input$test == 'confidence.interval'){\r\n      if(input$param == 'two.means'){\r\n\r\n        ot = two.sample.t.CI(x1 = input$xbar1,\r\n                        x2 = input$xbar2,\r\n                        s1 = input$s1,\r\n                        s2 = input$s2,\r\n                        n1 = input$n1,\r\n                        n2 = input$n2,\r\n                        tail = 'two.tail',\r\n                        alpha = input$alpha,\r\n                        verbose = T)\r\n\r\n      }else{\r\n        ot = two.sample.prop.CI(p1 = input$x1/input$n1,\r\n                           p2 = input$x2/input$n2,\r\n                           n1 = input$n1,\r\n                           n2 = input$n2,\r\n                           tail = 'two.tail',\r\n                           alpha = input$alpha,\r\n                           verbose  = T)\r\n      }\r\n    }else{\r\n      if(input$param == 'two.means'){\r\n        two.sample.t.test(m0 = input$m0,\r\n                          x1 = input$xbar1,\r\n                          x2 = input$xbar2,\r\n                          s1 = input$s1,\r\n                          s2 = input$s2,\r\n                          n1 = input$n1,\r\n                          n2 = input$n2,\r\n                          alpha = input$alpha,\r\n                          test = input$test,\r\n                          pooling = input$pooling,\r\n                          verbose = T)\r\n\r\n      }else{\r\n        two.sample.prop.test(p0 = input$p0,\r\n                             x1 = input$x1,\r\n                             x2 = input$x2,\r\n                             n1 = input$n1,\r\n                             n2 = input$n2,\r\n                             alpha = input$alpha,\r\n                             test = input$test,\r\n                             pooled = TRUE,\r\n                             verbose = T)\r\n      }\r\n    }\r\n\r\n  }))\r\n}\r\n\r\n# Run the application \r\nshinyApp(ui = ui, server = server)\r\n","type":"text"},{"name":"deploy_app.R","content":"path = 'C:/Users/Bruin/Documents/GitHub/UI_STAT251-03_Spring_2024/docs/shiny_apps/two_sample_hypothesis_tests/'\r\noutpath = 'C:/Users/Bruin/Documents/GitHub/UI_STAT251-03_Spring_2024/docs/shiny_apps/two_sample_hypothesis_tests/webfiles/'\r\nshinylive::export(appdir = path, destdir = outpath)\r\nhttpuv::runStaticServer(\"C:/Users/Bruin/Documents/GitHub/UI_STAT251-03_Spring_2024/docs/shiny_apps/two_sample_hypothesis_tests/webfiles/\")\r\n","type":"text"}]
